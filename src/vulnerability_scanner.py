#!/usr/bin/env python3
"""
Vulnerability Scanner for IHACPA Python Package Review Automation
Handles scanning multiple vulnerability databases for Python packages
"""

import asyncio
import aiohttp
import requests
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple
import logging
import re
from urllib.parse import urljoin, quote


class VulnerabilityScanner:
    """Scanner for checking multiple vulnerability databases"""
    
    DATABASES = {
        'nist_nvd': {
            'name': 'NIST NVD',
            'base_url': 'https://services.nvd.nist.gov/rest/json/cves/2.0',
            'search_param': 'keywordSearch',
            'enabled': True
        },
        'mitre_cve': {
            'name': 'MITRE CVE',
            'base_url': 'https://cve.mitre.org/cgi-bin/cvekey.cgi',
            'search_param': 'keyword',
            'enabled': True
        },
        'snyk': {
            'name': 'SNYK',
            'base_url': 'https://security.snyk.io/vuln/pip',
            'search_param': 'package',
            'enabled': True
        },
        'exploit_db': {
            'name': 'Exploit Database',
            'base_url': 'https://www.exploit-db.com/search',
            'search_param': 'text',
            'enabled': True
        },
        'github_advisory': {
            'name': 'GitHub Security Advisory',
            'base_url': 'https://github.com/advisories',
            'search_param': 'query',
            'enabled': True
        }
    }
    
    def __init__(self, timeout: int = 30, max_retries: int = 3, rate_limit: float = 1.0):
        """Initialize vulnerability scanner"""
        self.timeout = timeout
        self.max_retries = max_retries
        self.rate_limit = rate_limit  # Seconds between requests
        self.session = None
        self.logger = logging.getLogger(__name__)
        self.last_request_time = {}
        
    async def _rate_limited_request(self, database: str, url: str, params: Dict = None) -> Optional[Dict]:
        """Make rate-limited request to avoid overwhelming APIs"""
        current_time = datetime.now()
        
        if database in self.last_request_time:
            time_since_last = (current_time - self.last_request_time[database]).total_seconds()
            if time_since_last < self.rate_limit:
                await asyncio.sleep(self.rate_limit - time_since_last)
        
        self.last_request_time[database] = current_time
        
        if not self.session:
            self.session = aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=self.timeout))
        
        for attempt in range(self.max_retries):
            try:
                async with self.session.get(url, params=params) as response:
                    if response.status == 200:
                        return await response.json()
                    elif response.status == 404:
                        self.logger.debug(f"No data found for {url}")
                        return None
                    else:
                        self.logger.warning(f"HTTP {response.status} for {url}")
                        
            except asyncio.TimeoutError:
                self.logger.warning(f"Timeout on attempt {attempt + 1} for {url}")
                
            except aiohttp.ClientError as e:
                self.logger.error(f"Client error on attempt {attempt + 1} for {url}: {e}")
                
            except Exception as e:
                self.logger.error(f"Unexpected error for {url}: {e}")
                
            if attempt < self.max_retries - 1:
                await asyncio.sleep(2 ** attempt)
                
        return None
    
    def _build_search_urls(self, package_name: str) -> Dict[str, str]:
        """Build search URLs for all databases"""
        urls = {}
        
        # NIST NVD
        urls['nist_nvd'] = f"{self.DATABASES['nist_nvd']['base_url']}?keywordSearch={quote(package_name)}"
        
        # MITRE CVE
        urls['mitre_cve'] = f"{self.DATABASES['mitre_cve']['base_url']}?keyword={quote(package_name)}"
        
        # SNYK
        urls['snyk'] = f"{self.DATABASES['snyk']['base_url']}/{quote(package_name)}"
        
        # Exploit Database
        urls['exploit_db'] = f"{self.DATABASES['exploit_db']['base_url']}?text={quote(package_name)}"
        
        # GitHub Security Advisory
        urls['github_advisory'] = f"{self.DATABASES['github_advisory']['base_url']}?query={quote(f'ecosystem:pip {package_name}')}"
        
        return urls
    
    async def scan_nist_nvd(self, package_name: str) -> Dict[str, Any]:
        """Scan NIST NVD database"""
        try:
            url = f"{self.DATABASES['nist_nvd']['base_url']}?keywordSearch={quote(package_name)}"
            
            data = await self._rate_limited_request('nist_nvd', url)
            if not data:
                return self._empty_result('nist_nvd', package_name, url)
            
            vulnerabilities = data.get('vulnerabilities', [])
            results = []
            
            for vuln in vulnerabilities:
                cve_data = vuln.get('cve', {})
                cve_id = cve_data.get('id', '')
                
                # Check if vulnerability is actually related to the package
                description = cve_data.get('descriptions', [{}])[0].get('value', '')
                if package_name.lower() in description.lower():
                    severity = 'Unknown'
                    score = 'N/A'
                    
                    # Get CVSS score
                    metrics = cve_data.get('metrics', {})
                    cvss_v3 = metrics.get('cvssMetricV31', [])
                    if cvss_v3:
                        cvss_data = cvss_v3[0].get('cvssData', {})
                        score = cvss_data.get('baseScore', 'N/A')
                        severity = cvss_data.get('baseSeverity', 'Unknown')
                    
                    results.append({
                        'cve_id': cve_id,
                        'description': description[:200] + '...' if len(description) > 200 else description,
                        'severity': severity,
                        'score': score,
                        'published': cve_data.get('published', ''),
                        'modified': cve_data.get('lastModified', '')
                    })
            
            return {
                'database': 'NIST NVD',
                'package_name': package_name,
                'search_url': url,
                'found_vulnerabilities': len(results) > 0,
                'vulnerability_count': len(results),
                'vulnerabilities': results,
                'summary': f"Found {len(results)} vulnerabilities in NIST NVD" if results else "No vulnerabilities found in NIST NVD",
                'scanned_at': datetime.now().isoformat()
            }
            
        except Exception as e:
            self.logger.error(f"Error scanning NIST NVD for {package_name}: {e}")
            return self._error_result('nist_nvd', package_name, str(e))
    
    async def scan_mitre_cve(self, package_name: str) -> Dict[str, Any]:
        """Scan MITRE CVE database"""
        try:
            url = f"{self.DATABASES['mitre_cve']['base_url']}?keyword={quote(package_name)}"
            
            # MITRE CVE search returns HTML, so we'll create a placeholder result
            # In a full implementation, you'd parse the HTML response
            return {
                'database': 'MITRE CVE',
                'package_name': package_name,
                'search_url': url,
                'found_vulnerabilities': False,
                'vulnerability_count': 0,
                'vulnerabilities': [],
                'summary': f"Manual review required - check {url}",
                'scanned_at': datetime.now().isoformat(),
                'note': 'MITRE CVE requires manual review of search results'
            }
            
        except Exception as e:
            self.logger.error(f"Error scanning MITRE CVE for {package_name}: {e}")
            return self._error_result('mitre_cve', package_name, str(e))
    
    async def scan_snyk(self, package_name: str) -> Dict[str, Any]:
        """Scan SNYK vulnerability database"""
        try:
            url = f"{self.DATABASES['snyk']['base_url']}/{quote(package_name)}"
            
            # SNYK also returns HTML, so we'll create a placeholder result
            return {
                'database': 'SNYK',
                'package_name': package_name,
                'search_url': url,
                'found_vulnerabilities': False,
                'vulnerability_count': 0,
                'vulnerabilities': [],
                'summary': f"Manual review required - check {url}",
                'scanned_at': datetime.now().isoformat(),
                'note': 'SNYK requires manual review of search results'
            }
            
        except Exception as e:
            self.logger.error(f"Error scanning SNYK for {package_name}: {e}")
            return self._error_result('snyk', package_name, str(e))
    
    async def scan_exploit_db(self, package_name: str) -> Dict[str, Any]:
        """Scan Exploit Database"""
        try:
            url = f"{self.DATABASES['exploit_db']['base_url']}?text={quote(package_name)}"
            
            return {
                'database': 'Exploit Database',
                'package_name': package_name,
                'search_url': url,
                'found_vulnerabilities': False,
                'vulnerability_count': 0,
                'vulnerabilities': [],
                'summary': f"Manual review required - check {url}",
                'scanned_at': datetime.now().isoformat(),
                'note': 'Exploit Database requires manual review of search results'
            }
            
        except Exception as e:
            self.logger.error(f"Error scanning Exploit Database for {package_name}: {e}")
            return self._error_result('exploit_db', package_name, str(e))
    
    async def scan_github_advisory(self, package_name: str, github_url: str = None) -> Dict[str, Any]:
        """Scan GitHub Security Advisory"""
        try:
            if github_url and 'github.com' in github_url:
                # If we have a GitHub URL, use the specific repository advisory URL
                repo_match = re.search(r'github\.com/([^/]+)/([^/]+)', github_url)
                if repo_match:
                    owner, repo = repo_match.groups()
                    url = f"https://github.com/{owner}/{repo}/security/advisories"
                else:
                    url = f"{self.DATABASES['github_advisory']['base_url']}?query={quote(f'ecosystem:pip {package_name}')}"
            else:
                url = f"{self.DATABASES['github_advisory']['base_url']}?query={quote(f'ecosystem:pip {package_name}')}"
            
            return {
                'database': 'GitHub Security Advisory',
                'package_name': package_name,
                'search_url': url,
                'found_vulnerabilities': False,
                'vulnerability_count': 0,
                'vulnerabilities': [],
                'summary': f"Manual review required - check {url}",
                'scanned_at': datetime.now().isoformat(),
                'note': 'GitHub Security Advisory requires manual review of search results'
            }
            
        except Exception as e:
            self.logger.error(f"Error scanning GitHub Advisory for {package_name}: {e}")
            return self._error_result('github_advisory', package_name, str(e))
    
    async def scan_all_databases(self, package_name: str, github_url: str = None) -> Dict[str, Any]:
        """Scan all databases for a package"""
        self.logger.info(f"Scanning all databases for package: {package_name}")
        
        # Create tasks for all database scans
        tasks = [
            self.scan_nist_nvd(package_name),
            self.scan_mitre_cve(package_name),
            self.scan_snyk(package_name),
            self.scan_exploit_db(package_name),
            self.scan_github_advisory(package_name, github_url)
        ]
        
        # Run all scans concurrently
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Process results
        scan_results = {}
        total_vulnerabilities = 0
        databases_with_vulnerabilities = []
        
        database_names = ['nist_nvd', 'mitre_cve', 'snyk', 'exploit_db', 'github_advisory']
        
        for i, result in enumerate(results):
            db_name = database_names[i]
            
            if isinstance(result, Exception):
                self.logger.error(f"Error scanning {db_name}: {result}")
                scan_results[db_name] = self._error_result(db_name, package_name, str(result))
            else:
                scan_results[db_name] = result
                if result.get('found_vulnerabilities', False):
                    total_vulnerabilities += result.get('vulnerability_count', 0)
                    databases_with_vulnerabilities.append(result.get('database', db_name))
        
        # Generate summary
        if total_vulnerabilities > 0:
            summary = f"Found {total_vulnerabilities} vulnerabilities across {len(databases_with_vulnerabilities)} databases"
        else:
            summary = "No vulnerabilities found in any database"
        
        return {
            'package_name': package_name,
            'scan_results': scan_results,
            'total_vulnerabilities': total_vulnerabilities,
            'databases_with_vulnerabilities': databases_with_vulnerabilities,
            'summary': summary,
            'scanned_at': datetime.now().isoformat(),
            'scan_urls': self._build_search_urls(package_name)
        }
    
    def _empty_result(self, database: str, package_name: str, url: str) -> Dict[str, Any]:
        """Generate empty result structure"""
        return {
            'database': self.DATABASES[database]['name'],
            'package_name': package_name,
            'search_url': url,
            'found_vulnerabilities': False,
            'vulnerability_count': 0,
            'vulnerabilities': [],
            'summary': f"No vulnerabilities found in {self.DATABASES[database]['name']}",
            'scanned_at': datetime.now().isoformat()
        }
    
    def _error_result(self, database: str, package_name: str, error_msg: str) -> Dict[str, Any]:
        """Generate error result structure"""
        return {
            'database': self.DATABASES[database]['name'],
            'package_name': package_name,
            'search_url': '',
            'found_vulnerabilities': False,
            'vulnerability_count': 0,
            'vulnerabilities': [],
            'summary': f"Error scanning {self.DATABASES[database]['name']}: {error_msg}",
            'scanned_at': datetime.now().isoformat(),
            'error': error_msg
        }
    
    def generate_recommendations(self, package_name: str, current_version: str, 
                               latest_version: str, vulnerability_results: Dict[str, Any]) -> str:
        """Generate recommendations based on scan results"""
        recommendations = []
        
        # Check for version updates
        if current_version != latest_version:
            recommendations.append(f"Update from {current_version} to {latest_version}")
        
        # Check vulnerability count
        total_vulns = vulnerability_results.get('total_vulnerabilities', 0)
        
        if total_vulns > 0:
            recommendations.append(f"SECURITY RISK: {total_vulns} vulnerabilities found")
            recommendations.append("Review security advisories before deployment")
            
            # Check severity if available
            for db_name, result in vulnerability_results.get('scan_results', {}).items():
                if result.get('found_vulnerabilities', False):
                    for vuln in result.get('vulnerabilities', []):
                        severity = vuln.get('severity', 'Unknown')
                        if severity.upper() in ['CRITICAL', 'HIGH']:
                            recommendations.append(f"HIGH PRIORITY: {severity} severity vulnerability found")
                            break
        
        if not recommendations:
            if current_version == latest_version:
                recommendations.append("No issues found - current version is up to date")
            else:
                recommendations.append("Consider updating to latest version")
        
        return " | ".join(recommendations)
    
    async def close(self):
        """Close async session"""
        if self.session:
            await self.session.close()
            self.session = None


class SynchronousVulnerabilityScanner:
    """Synchronous wrapper for vulnerability scanning"""
    
    def __init__(self, timeout: int = 30, max_retries: int = 3):
        self.scanner = VulnerabilityScanner(timeout, max_retries)
    
    def scan_package(self, package_name: str, github_url: str = None) -> Dict[str, Any]:
        """Synchronous scan of a single package"""
        return asyncio.run(self.scanner.scan_all_databases(package_name, github_url))
    
    def scan_packages(self, package_names: List[str]) -> Dict[str, Dict[str, Any]]:
        """Synchronous scan of multiple packages"""
        results = {}
        for package_name in package_names:
            results[package_name] = self.scan_package(package_name)
        return results
    
    def close(self):
        """Close scanner"""
        asyncio.run(self.scanner.close())